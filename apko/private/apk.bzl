"Repository rules for importing remote apk packages"

load(":util.bzl", "util")

APK_IMPORT_TMPL = """\
# Generated by apk_import. DO NOT EDIT
filegroup(
    name = "all", 
    srcs = glob(["**/*.tar.gz", "**/*.apk"]),
    visibility = ["//visibility:public"]
)
"""

def _range(url, range):
    return "{}#_apk_range_{}".format(url, range.replace("=", "_"))

def _check_initial_setup(rctx):
    output = rctx.path(".rangecheck/output")
    rctx.download(
        url = [_range(rctx.attr.url, "bytes=0-0")],
        output = output,
    )
    r = rctx.execute(["wc", "-c", output])

    if r.return_code != 0:
        fail("initial setup check failed ({}) stderr: {}\n stdout: {}".format(r.statuscode, r.stderr, r.stdout))

    bytes = r.stdout.lstrip(" ").split(" ")

    if bytes[0] != "1":
        fail("""

â€¼ï¸ We encountered an issue with your current configuration that prevents partial package fetching during downloads. 

This may indicate either a misconfiguration or that the initial setup hasn't been performed correctly.
To resolve this issue and enable partial package fetching, please follow the step-by-step instructions in our documentation. 

ğŸ“š Documentation: https://github.com/chainguard-dev/rules_apko/blob/main/docs/initial-setup.md

""".format(bytes[0]))

def _apk_import_impl(rctx):
    repo = util.repo_url(rctx.attr.url, rctx.attr.architecture)
    repo_escaped = util.url_escape(repo)

    output = "{}/{}/{}-{}".format(repo_escaped, rctx.attr.architecture, rctx.attr.package_name, rctx.attr.version)

    control_sha256 = util.normalize_sri(rctx, rctx.attr.control_checksum)
    data_sha256 = util.normalize_sri(rctx, rctx.attr.data_checksum)

    sig_output = "{}/{}.sig.tar.gz".format(output, control_sha256)
    control_output = "{}/{}.ctl.tar.gz".format(output, control_sha256)
    data_output = "{}/{}.dat.tar.gz".format(output, data_sha256)
    apk_output = "{}/{}/{}-{}.apk".format(repo_escaped, rctx.attr.architecture, rctx.attr.package_name, rctx.attr.version)

    # TODO: Migrate to block API: https://github.com/bazelbuild/bazel/issues/19674 when released in bazel (7.1?).
    sig_download_res1 = rctx.download(
        url = [_range(rctx.attr.url, rctx.attr.signature_range)],
        output = sig_output,
        integrity = rctx.attr.signature_checksum,
        allow_fail = True,
    )
    if not sig_download_res1.success:
        sig_download_res2 = rctx.download(
            url = [_range(rctx.attr.url, rctx.attr.signature_range)],
            output = sig_output,
            allow_fail = False,
        )
        print(("Signature of pkg:{package_name} out of sync with the lock-file (downloaded: {down} expected: {exp})." +
               " The signatures are known to be unstable. Please regenerate the lock-files.").format(
            package_name = rctx.attr.package_name,
            down = rctx.attr.signature_checksum,
            exp = sig_download_res2.integrity,
        ))  # buildifier: disable=print

    rctx.download(
        url = [_range(rctx.attr.url, rctx.attr.control_range)],
        output = control_output,
        integrity = rctx.attr.control_checksum,
    )
    rctx.download(
        url = [_range(rctx.attr.url, rctx.attr.data_range)],
        output = data_output,
        integrity = rctx.attr.data_checksum,
    )

    util.concatenate_gzip_segments(
        rctx,
        output = apk_output,
        signature = sig_output,
        control = control_output,
        data = data_output,
    )
    rctx.file("BUILD.bazel", APK_IMPORT_TMPL)

apk_import = repository_rule(
    implementation = _apk_import_impl,
    attrs = {
        "package_name": attr.string(mandatory = True),
        "version": attr.string(mandatory = True),
        "architecture": attr.string(mandatory = True),
        "url": attr.string(mandatory = True),
        "signature_range": attr.string(mandatory = True),
        "signature_checksum": attr.string(mandatory = True),
        "control_range": attr.string(mandatory = True),
        "control_checksum": attr.string(mandatory = True),
        "data_range": attr.string(mandatory = True),
        "data_checksum": attr.string(mandatory = True),
    },
)

APK_REPOSITORY_TMPL = """\
# Generated by apk_repository. DO NOT EDIT
filegroup(
    name = "index", 
    srcs = glob(["**/APKINDEX/*.tar.gz"]),
    visibility = ["//visibility:public"]
)
"""

def _apk_repository_impl(rctx):
    repo = util.repo_url(rctx.attr.url, rctx.attr.architecture)
    repo_escaped = util.url_escape(repo)
    _check_initial_setup(rctx)
    rctx.download(
        url = [rctx.attr.url],
        output = "{}/{}/APKINDEX/latest.tar.gz".format(repo_escaped, rctx.attr.architecture),
    )
    rctx.file("BUILD.bazel", APK_REPOSITORY_TMPL)

apk_repository = repository_rule(
    implementation = _apk_repository_impl,
    attrs = {
        "url": attr.string(mandatory = True),
        "architecture": attr.string(mandatory = True),
    },
)

APK_KEYRING_TMPL = """\
# Generated by apk_import. DO NOT EDIT
filegroup(
    name = "keyring", 
    srcs = ["{public_key}"],
    visibility = ["//visibility:public"]
)
"""

def _cachePathFromURL(url):
    """
    Translates URL to a name of local directory that can be used to represent prefetched content of the URL.

    Mimicks https://github.com/chainguard-dev/go-apk/blob/7b08e8f3b0fcaa0f0a44757aedf23f6778cd8e4f/pkg/apk/cache.go#L326C6-L326C22
    Is interprets URL as following path: {repo}/{arch}/{file} [but also used for keyring files that don't obey {arch} part].

    Examples:
      https://packages.wolfi.dev/os/wolfi-signing.rsa.pub              -> https%3A%2F%2Fpackages.wolfi.dev%2F/os/wolfi-signing.rsa.pub
      https://packages.wolfi.dev/os/aarch64/sqlite-libs-3.44.0-r0.apk  -> https%3A%2F%2Fpackages.wolfi.dev%2Fos/arch64/sqlite-libs-3.44.0-r0.apk
    """
    url_split = url.rsplit("/", 2)
    repo = url_split[0]
    if len(repo.split("/")) <= 3:
        # Seems the Apko adds additional "/" if the URL is short.
        repo += "/"
    repo_escaped = util.url_escape(repo)
    return "{}/{}/{}".format(repo_escaped, url_split[1], url_split[2])

def _apk_keyring_impl(rctx):
    public_key = _cachePathFromURL(rctx.attr.url)
    rctx.download(url = [rctx.attr.url], output = public_key)
    rctx.file("BUILD.bazel", APK_KEYRING_TMPL.format(public_key = public_key))

apk_keyring = repository_rule(
    implementation = _apk_keyring_impl,
    attrs = {
        "url": attr.string(mandatory = True),
    },
)
