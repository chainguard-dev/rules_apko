#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail

SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

REPOSITORY=${1:-"chainguard-dev/apko"}
TOOL=${2:-"apko"}
CREATE_PR=${3:-"false"}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to retry commands with exponential backoff
retry() {
    local max_attempts=3
    local delay=1
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if "$@"; then
            return 0
        else
            if [ $attempt -eq $max_attempts ]; then
                error "Command failed after $max_attempts attempts: $*"
                return 1
            fi
            warn "Attempt $attempt failed, retrying in ${delay}s..."
            sleep $delay
            delay=$((delay * 2))
            attempt=$((attempt + 1))
        fi
    done
}

# Function to validate JSON structure
validate_release_data() {
    local file="$1"
    if ! jq empty "$file" 2>/dev/null; then
        error "Invalid JSON in release data"
        return 1
    fi
    
    local tag_count
    tag_count=$(jq 'length' "$file")
    if [ "$tag_count" -eq 0 ]; then
        error "No release data found"
        return 1
    fi
    
    return 0
}

# Function to get current version from MODULE.bazel
get_current_version() {
    grep 'toolchain.toolchain(apko_version = ' MODULE.bazel | sed -n 's/.*apko_version = "\([^"]*\)".*/\1/p'
}

# Function to check if version is newer
is_newer_version() {
    local current="$1"
    local new="$2"
    
    # Remove 'v' prefix for comparison
    current="${current#v}"
    new="${new#v}"
    
    # Use sort -V for version comparison
    if [ "$(echo -e "$current\n$new" | sort -V | tail -n1)" = "$new" ] && [ "$current" != "$new" ]; then
        return 0
    else
        return 1
    fi
}

# Function to create PR if needed
create_pull_request() {
    local new_version="$1"
    
    if [ "$CREATE_PR" != "true" ]; then
        log "PR creation disabled, skipping..."
        return 0
    fi
    
    # Check if we have uncommitted changes
    if ! git diff --quiet; then
        log "Creating branch and committing changes..."
        
        local branch_name="update-apko-${new_version}"
        git checkout -b "$branch_name"
        git add MODULE.bazel apko/private/versions.bzl apko/tests/versions_test.bzl
        
        git commit -m "chore: update apko to ${new_version}

This automated update includes:
- Updated apko version from $(get_current_version) to ${new_version}
- Updated integrity hashes for all platforms
- Updated test expectations

Generated by scripts/mirror_apko.sh"
        
        # Push branch
        git push origin "$branch_name"
        
        # Create PR using gh CLI
        if command -v gh &> /dev/null; then
            log "Creating pull request..."
            gh pr create \
                --title "chore: update apko to ${new_version}" \
                --body "$(cat <<EOF
## Summary
- Updates apko from $(get_current_version) to ${new_version}
- Updates integrity hashes for all supported platforms
- Updates test version expectations

## Changes
- \`MODULE.bazel\`: Updated apko_version
- \`apko/private/versions.bzl\`: Updated version data and checksums
- \`apko/tests/versions_test.bzl\`: Updated test expectations

## Test Plan
- [ ] CI tests pass
- [ ] Build succeeds with new version
- [ ] Integration tests pass

## Release Notes
See [apko ${new_version} release](https://github.com/${REPOSITORY}/releases/tag/${new_version}) for details.

---
ðŸ¤– This PR was automatically generated by \`scripts/mirror_apko.sh\`
EOF
)" \
                --label "dependencies" \
                --label "automated"
        else
            warn "gh CLI not available, skipping PR creation"
            log "Branch '$branch_name' created and pushed. Please create PR manually."
        fi
    else
        log "No changes detected, skipping PR creation"
    fi
}

# Function to rollback changes on failure
rollback_changes() {
    warn "Rolling back changes due to error..."
    git checkout -- MODULE.bazel apko/private/versions.bzl apko/tests/versions_test.bzl 2>/dev/null || true
}

# Main execution
main() {
    log "Starting apko mirror process..."
    
    # Ensure we're in git repo root
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository"
        exit 1
    fi
    
    # Ensure working directory is clean if creating PR
    if [ "$CREATE_PR" = "true" ] && ! git diff --quiet; then
        error "Working directory has uncommitted changes. Please commit or stash them first."
        exit 1
    fi
    
    local current_version
    current_version=$(get_current_version)
    log "Current apko version: $current_version"
    
    # Create temp files
    local raw_file
    local fixed_file
    raw_file=$(mktemp)
    fixed_file=$(mktemp)
    
    # Cleanup temp files on exit
    trap 'rm -f "$raw_file" "$fixed_file"; rollback_changes' EXIT
    
    log "Fetching latest release from GitHub..."
    
    # Fetch release data with retry
    if ! retry curl --silent --fail \
        --header "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/${REPOSITORY}/releases?per_page=1" \
        | jq -f "$SCRIPT_DIR/filter_${TOOL}.jq" > "$raw_file"; then
        error "Failed to fetch release data from GitHub"
        exit 1
    fi
    
    # Validate release data
    if ! validate_release_data "$raw_file"; then
        exit 1
    fi
    
    # Get the new version
    local new_version
    new_version=$(jq -r 'keys[0]' "$raw_file")
    log "Latest available version: $new_version"
    
    # Check if update is needed
    if ! is_newer_version "$current_version" "$new_version"; then
        log "Already up to date (current: $current_version, latest: $new_version)"
        exit 0
    fi
    
    log "Update needed: $current_version -> $new_version"
    
    # Process checksums for each tag
    log "Processing checksums..."
    for tag in $(jq -r 'keys | .[]' < "$raw_file"); do
        log "Processing checksums for $tag..."
        
        local checksums_url="https://github.com/${REPOSITORY}/releases/download/$tag/checksums.txt"
        local checksums
        
        if ! checksums=$(retry curl --silent --fail --location "$checksums_url"); then
            error "Failed to fetch checksums for $tag"
            exit 1
        fi
        
        if [ -z "$checksums" ]; then
            error "Empty checksums file for $tag"
            exit 1
        fi
        
        # Process each checksum
        while read -r sha256 filename; do
            if [ -n "$sha256" ] && [ -n "$filename" ]; then
                local integrity
                integrity="sha256-$(echo "$sha256" | xxd -r -p | base64)"
                
                # Update the JSON with integrity hash
                jq --indent 4 ".[\"$tag\"] |= with_entries(.value = (if .value == \"$filename\" then \"$integrity\" else .value end))" < "$raw_file" > "$fixed_file"
                mv "$fixed_file" "$raw_file"
            fi
        done <<< "$checksums"
    done
    
    log "Updating apko/private/versions.bzl..."
    
    # Generate the new versions.bzl file
    cat > apko/private/versions.bzl << EOF
"""Mirror of release info"""

# Add new versions by running
# ./scripts/mirror_apko.sh
EOF
    
    echo -n "$(echo "$TOOL" | tr '[:lower:]' '[:upper:]')_VERSIONS = " >> apko/private/versions.bzl
    sed 's|"$|",|;s| }$| },|' < "$raw_file" >> apko/private/versions.bzl
    
    log "Updating MODULE.bazel and test files..."
    
    # Update MODULE.bazel and test file with new version
    sed "s|\"v[0-9.]*\"|\"$new_version\"|" -i MODULE.bazel apko/tests/versions_test.bzl
    
    log "Successfully updated to $new_version"
    
    # Create PR if requested
    create_pull_request "$new_version"
    
    # Clear trap since we succeeded
    trap - EXIT
    rm -f "$raw_file" "$fixed_file"
    
    log "Mirror process completed successfully!"
}

# Run main function
main "$@"
